[
  {
    "id": "32ee5e67-f9fc-4ca3-a69d-c2e452dc027a",
    "slug": "apa-itu-hibuno-com",
    "title": "Apa itu Hibuno.com?",
    "excerpt": "Mari berkenalan dengan hibuno.com sebuah portofolio pribadi Muhibbudin Suretno. Yang menampilkan artikel, tutorial, maupun proyek sumber terbuka secara gratis.",
    "content": "<p>Perkenalkan, saya <strong>Muhibbudin Suretno</strong>. Pembuat dan pemelihara situs <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"http://hibuno.com\" style=\"cursor: pointer;\">hibuno.com</a>, situs ini merupakan portofolio pribadi saya dimana akan memuat beberapa artikel, tutorial, dan proyek sumber terbuka <em>(open source)</em> maupun berbayar. Proyek yang saya maksud bisa berupa <em>user interface template</em>, kerangka kerja, <em>prototype</em>, <em>micro-service</em>, atau proyek siap pakai dalam bentuk website, aplikasi desktop maupun aplikasi mobile.</p><h3>Kenapa namanya <em>hibuno</em>?</h3><p>Tidak ada alasan khusus, <strong>hibuno</strong> sendiri sebenarnya merupakan singkatan dari nama saya, yaitu Mu<strong>hib</strong>budin S<strong>u</strong>ret<strong>no</strong>. Karena seringkali orang lain sedikit kesulitan untuk mengucap atau menulis nama lengkap saya, jadi dengan singkatan ini saya berharap akan lebih mempermudah orang lain, dan tentunya agar lebih mudah juga untuk diucapkan sebagai <em>username</em> <em>social media</em> misalnya.</p><h3>Apa yang akan dibahas?</h3><p>Sederhananya gini tulisan yang kamu baca sekarang, saat ini di simpan di sebuah file bernama <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://github.com/hibuno/hibuno/blob/main/content/posts/index.json\" style=\"cursor: pointer;\">index.json</a> pada <em>repository</em> <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://github.com/hibuno/hibuno\" style=\"cursor: pointer;\">https://github.com/hibuno/hibuno</a> yang tentunya dapat kamu akses &amp; pelajari secara gratis. Jadi saya coba buat sendiri sebuah <em>content management system</em> yang mudah digunakan, proses loading-nya sangat cepat, murah (baca: gratis) bisa di jalankan di Vercel, Netlify, atau provider lainnya, serta memiliki <em>text editor</em> berbasis akal imitasi (AI).</p><p>Dan tentunya <em>repository</em> yang saya sematkan sebelumnya tidak hanya menyimpan konten untuk artikel, tapi juga keseluruhan situs termasuk <em>admin panel</em>, <em>text editor (WYSIWYG: what you see is what you get)</em>, serta beberapa fitur lain yang dapat kamu pelajari secara mendalam pada kode sumber yang tersedia.</p><p>Dimana <em>text-editor</em>nya sendiri saya buat dari awal berlandaskan pada <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://tiptap.dev/\" style=\"cursor: pointer;\">https://tiptap.dev</a> dengan beberapa tambahan fitur custom, serta integrasi akal imitas yang dapat disambungkan dengan provider ternama seperti OpenAI, OpenRouter, Claude, Mistral, dst. untuk dapat membantu kamu membuat artikel yang lebih rapi, tertata, dan <em>grammar friendly</em>, untuk tampilannya sendiri adalah sebagai berikut.</p><img src=\"/images/uploads/Screenshot-2025-12-05-at-17.48.18-1764931709348-e7on18.png\" data-width=\"100%\" data-alignment=\"center\"><h3>Bedanya sama CMS lainnya?</h3><p>Kalau secara fitur memang sangat <em>mature</em> dan lengkap WordPress, namun karena saya mengejar sebuah kesederhanaan, tidak hanya dalam proses penulisan artikel tapi juga pengiriman (baca: <em>deployment</em>) yang lebih mudah.</p><p>Pada situs ini saya menggunakan teknologi Next.js 15.5 dengan konsep SSR dimana <em>editor</em> akan menyimpan data pada direktori <em>content</em> sedangkan gambar disimpan di direktori <em>public</em>. Artinya, situs ini sama sekali tidak menggunakan basis data maupun pihak ketiga untuk menyimpan setiap datanya, dan (saat ini) hanya menggunakan satu layanan akal imitasi (AI) untuk menjalankan fitur asisten AI.</p><p><strong>Loh kalo gitu, gimana cara nambahin datanya? Apakah aman?</strong></p><p>Aman atau tidak itu relative, tergantung gimana kita menyimpan kuncinya. Situs ini hanya menggunakan satu kunci (<em>basic key</em>) sebagai pembatas antara pembaca dan administrator, jika kamu mengakses halaman <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://hibuno.com/admin\" style=\"cursor: pointer;\">https://hibuno.com/admin</a> tentunya kamu akan ditanya apakah kamu memiliki kunci untuk mengakses halaman admin atau tidak.</p><p>Dan kunci ini tersimpan rapat di dokumen <em>environment variable</em> di mana situs ini dijalankan, tapi sebenarnya tidak ada data yang terlalu penting di situs ini, karena pada akhirnya setiap tulisan yang saya unggah juga dapat di baca di repository publik yang tersedia termasuk dengan gambar ataupun video yang ditampilkan.</p><h3>Penutup, tapi juga bukan â€¦</h3><p>Sebelum penutup kalimat, mari kita pelajari lebih jauh apa saja fitur yang tersedia di <em>text editor</em> berbasis akal imitasi yang telah saya bahas sebelumnya, tentunya lewat video demonstrasi berikut, agar lebih jelas dan lebih mudah dipahami.</p><div class=\"video-wrapper my-4 text-center\" data-video-wrapper=\"true\"><video src=\"/videos/uploads/recording-1764995076866-1764996506283-kzzdhr.mp4\" title=\"\" width=\"100%\" data-alignment=\"center\" class=\"rounded-lg shadow-md mx-auto\" controls=\"true\" preload=\"metadata\" style=\"width: 100%; max-width: 100%;\"></video></div><p>Sekian pembahasan tentang artikel pertama di situs ini, semoga dapat menjadi gambaran bagaimana tulisan maupun konten yang akan saya buat selanjutnya.</p><p>See you next time ðŸ”¥</p><p>Oh iya, satu lagi. Alat yang saya pakai untuk merekam video demonstrasi adalah alat yang saya buat sendiri, jadi nanti kita bahas di lain kesempatan.</p><p></p>",
    "content_group_id": "0bc941c3-ad5c-49a4-969e-6b7ad153e6c5",
    "locale": "id",
    "cover_image_url": "/images/uploads/32ee5e67-f9fc-4ca3-a69d-c2e452dc027a-Screenshot-2025-12-05-at-17.48.18-1764935783149-jeieh8.png",
    "tags": [
      "hibuno",
      "muhibbudin-suretno",
      "website pribadi",
      "programmer",
      "portfolio"
    ],
    "published": "published",
    "published_at": "2025-12-05T02:40:06.299Z",
    "created_at": "2025-12-05T02:40:06.299Z",
    "updated_at": "2025-12-08T08:31:21.793Z",
    "price": null,
    "discount_percentage": null,
    "homepage": null,
    "product_description": null
  },
  {
    "id": "0a4fd5b5-1d3c-4a84-b576-9dc07d413e6a",
    "slug": "what-is-hibuno-com",
    "title": "What is Hibuno.com?",
    "excerpt": "Let's get acquainted with hibuno.com, Muhibbudin Suretno's personal portfolio, featuring free articles, tutorials, and open source projects.",
    "content": "<p>Let me introduce myself. I'm <strong>Muhibbudin Suretno</strong>. I'm the creator and maintainer of <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"http://hibuno.com\" style=\"cursor: pointer;\">hibuno.com</a>. This site serves as my personal portfolio, featuring articles, tutorials, and both open-source and paid projects. These projects can include user interface templates, frameworks, prototypes, microservices, or ready-to-use projects in the form of websites, desktop applications, or mobile apps.</p><h3>Why is it called hibuno?</h3><p>There's no specific reason; <strong>hibuno</strong> itself is actually an abbreviation of my name, Mu<strong>hib</strong>budin S<strong>u</strong>ret<strong>no</strong>. Because people often have difficulty pronouncing or writing my full name, I hope this abbreviation will make things easier for others, and of course, make it easier to pronounce as a social media username, for example.</p><h3>What will be discussed?</h3><p>Simply put, the text you're reading now is stored in a file called <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://github.com/hibuno/hibuno/blob/main/content/posts/index.json\" style=\"cursor: pointer;\">index.json</a> in the repository <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://github.com/hibuno/hibuno\" style=\"cursor: pointer;\">https://github.com/hibuno/hibuno</a>, which you can access and learn for free. So, I set out to create my own content management system that's easy to use, loads very quickly, is inexpensive (read: free), can run on Vercel, Netlify, or other providers, and includes an AI-based text editor.</p><p>And of course, the repository I previously embedded not only stores content for articles, but also the entire site, including the admin panel, text editor (WYSIWYG: what you see is what you get), and several other features that you can explore in depth in the available source code.</p><p>I built the text editor from scratch, based on <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://tiptap.dev\" style=\"cursor: pointer;\">https://tiptap.dev</a> with several additional custom features and AI integration that can be connected to well-known providers like OpenAI, OpenRouter, Claude, Mistral, etc. To help you create articles that are neater, more organized, and more grammar-friendly, the appearance itself is as follows.</p><img src=\"/images/uploads/Screenshot-2025-12-05-at-17.48.18-1764931709348-e7on18.png\" data-width=\"100%\" data-alignment=\"center\"><h3>How is it different from other CMSs?</h3><p>WordPress is indeed very mature and comprehensive in terms of features, but I'm pursuing simplicity, not only in the article writing process but also in easier delivery (read: deployment).</p><p>On this site, I use Next.js 15.5 technology with the SSR concept, where the editor stores data in the content directory, while images are stored in the public directory. This means the site uses no databases or third parties to store any of its data, and (currently) only uses a single artificial intelligence (AI) service to run the AI â€‹â€‹assistant feature.</p><p><strong>So, how do I add the data? Is it secure?</strong></p><p>Whether it's secure or not is relative, depending on how we store the key. This site only uses a single key (basic key) as a barrier between readers and administrators. If you access <a target=\"_blank\" rel=\"noopener noreferrer nofollow\" class=\"underline decoration-[var(--gold)]\" href=\"https://hibuno.com/admin\" style=\"cursor: pointer;\">https://hibuno.com/admin</a>, you'll be asked if you have the key to access the admin page.</p><p>This key is stored securely in the environment variables document where this site runs, but there's actually no particularly important data on this site, because ultimately, every post I upload can also be read in the available public repository, including the images or videos displayed.</p><h3>Conclusion, but also notâ€¦</h3><p>Before concluding, let's delve deeper into the features available in the artificial intelligence-based text editor I discussed earlier. Of course, through the following demonstration video, for clarity and easier understanding.</p><div class=\"video-wrapper my-4 text-center\" data-video-wrapper=\"true\"><video src=\"/videos/uploads/recording-1764995076866-1764996506283-kzzdhr.mp4\" title=\"\" width=\"100%\" data-alignment=\"center\" class=\"rounded-lg shadow-md mx-auto\" controls=\"true\" preload=\"metadata\" style=\"width: 100%; max-width: 100%;\"></video></div><p>That concludes my discussion of the first article on this site. I hope it gives you an idea of â€‹â€‹what kind of writing and content I'll be producing next.</p><p>See you next time ðŸ”¥</p><p>Oh yeah, one more thing. The equipment I used to record the demonstration video is one I made myself, so we'll discuss it another time.</p>",
    "content_group_id": "0bc941c3-ad5c-49a4-969e-6b7ad153e6c5",
    "locale": "en",
    "cover_image_url": "/images/uploads/32ee5e67-f9fc-4ca3-a69d-c2e452dc027a-Screenshot-2025-12-05-at-17.48.18-1764935783149-jeieh8.png",
    "tags": [
      "hibuno",
      "muhibbudin-suretno",
      "website pribadi",
      "programmer",
      "portfolio"
    ],
    "published": "published",
    "published_at": "2025-12-05T09:04:00.000Z",
    "created_at": "2025-12-08T08:25:12.256Z",
    "updated_at": "2025-12-08T09:04:46.085Z",
    "price": null,
    "discount_percentage": null,
    "homepage": null,
    "product_description": null
  },
  {
    "id": "eb711a6a-6192-4088-b4f9-6d77c5bb893c",
    "slug": "css-spinning-yin-yang",
    "title": "Building a Yin-Yang Loading Animation with CSS",
    "excerpt": "Master single-element CSS art by creating a classic spinning Yin-Yang symbol. This tutorial breaks down how to use gradients, pseudo-elements, and CSS keyframes to create complex geometry without images.",
    "content": "<p>In this tutorial, we will create a spinning Yin-Yang symbol. While this may look like a complex graphic, it can be constructed entirely using CSS and a single HTML element. This is a perfect exercise for understanding <strong>pseudo-elements</strong> (<code>::before</code> and <code>::after</code>) and CSS gradients.</p><h3>The Logic</h3><p>To build a Yin-Yang without images, we need to think about its geometry:</p><ul><li><p><strong>The Base:</strong> A main circle split into two colors (black and white).</p></li><li><p><strong>The Swirls:</strong> Two smaller circles placed on the centerline. One matches the top color but has a contrasting dot; the other matches the bottom color.</p></li></ul><h3>1. The HTML</h3><p>We only need a single container. We will use a <code>div</code> with the class <code>yin-yang</code>.</p><pre data-language=\"xml\" class=\"language-xml\"><code class=\"language-xml\">&lt;div class=\"balance\"&gt;&lt;/div&gt;</code></pre><h3>2. The CSS</h3><p>First, we style the main body. Instead of using complex border hacks, we use a <code>linear-gradient</code> to split the background perfectly in half.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">body {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  background-color: #363588;\n}\n\n.balance {\n  width: 100px;\n  height: 50px;\n  background-color: white;\n  border: 4px solid black;\n  border-bottom-width: 52px;\n  border-radius: 100%;\n  position: relative;\n  box-sizing: content-box;\n  animation: rotate 3s infinite linear;\n}</code></pre><h3>3. The Pseudo-Elements</h3><p>Now we use <code>::before</code> and <code>::after</code> to create the two inner circles. We use a border trick here: the <code>background-color</code> creates the small inner dot, while the <code>border</code> creates the swirling part of the circle.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">/* The top white/black swirl with a black dot */\n.balance::before,\n.balance::after {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 0;\n  width: 12.5px; /* The size of the inner dot */\n  height: 12.5px;\n  background-color: white;\n  border: 18.8px solid black; /* The border creates the black head */\n  border-radius: 100%;\n  box-sizing: content-box;\n}\n.balance::after {\n  left: 50%;\n  background-color: black;\n  border-color: white; /* The border creates the white head */\n}</code></pre><h3>4. The Animation</h3><p>Finally, we define the keyframes to make the symbol rotate continuously.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">@keyframes rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}</code></pre><h3>Summary</h3><p>By combining a linear gradient on the parent with centered pseudo-elements using thick borders, we achieved a scalable, resolution-independent Yin-Yang animation with zero JavaScript.</p>",
    "content_group_id": "0bc941c3-ad5c-49a4-6b7a-3daad153e6c5",
    "locale": "en",
    "cover_image_url": null,
    "tags": [
      "css",
      "animation",
      "yin yang",
      "pseudo-elements",
      "gradients"
    ],
    "published": true,
    "published_at": "2025-12-09T10:00:00.000Z",
    "created_at": "2025-12-09T08:46:52.852Z",
    "updated_at": "2025-12-09T10:09:07.518Z",
    "price": null,
    "discount_percentage": null,
    "homepage": null,
    "product_description": null,
    "social_media_links": [],
    "preview_enabled": true
  },
  {
    "id": "eb711a6a-6192-4088-b4f9-6d77c5bb893c",
    "slug": "yin-yang-berputar-dengan-css",
    "title": "Membuat Animasi Loading Yin-Yang dengan CSS",
    "excerpt": "Kuasai seni CSS satu elemen dengan membuat simbol Yin-Yang klasik yang berputar. Tutorial ini menguraikan cara menggunakan gradien, elemen semu (pseudo-elements), dan keyframe CSS untuk membuat geometri kompleks tanpa gambar.",
    "content": "<h2>Pendahuluan</h2><p>Dalam tutorial ini, kita akan membuat simbol Yin-Yang yang berputar. Meskipun terlihat seperti grafik yang rumit, simbol ini dapat dibangun sepenuhnya menggunakan CSS dan satu elemen HTML saja. Ini adalah latihan yang sempurna untuk memahami <strong>elemen semu</strong> (<code>::before</code> dan <code>::after</code>) dan gradien CSS.</p>[Gambar geometri simbol Yin Yang]<h3>Logika</h3><p>Untuk membangun Yin-Yang tanpa gambar, kita perlu memikirkan geometrinya:</p><ul><li><strong>Dasar (Base):</strong> Sebuah lingkaran utama yang dibagi menjadi dua warna (hitam dan putih).</li><li><strong>Pusaran (Swirls):</strong> Dua lingkaran lebih kecil yang ditempatkan di garis tengah. Satu lingkaran menyesuaikan warna atas tetapi memiliki titik kontras; yang lainnya menyesuaikan warna bawah.</li></ul><hr /><h3>1. HTML</h3><p>Kita hanya membutuhkan satu wadah (container). Kita akan menggunakan sebuah <code>div</code> dengan kelas <code>yin-yang</code>.</p><pre data-language=\"xml\" class=\"language-xml\"><code class=\"language-xml\">&lt;div class=\"balance\"&gt;&lt;/div&gt;</code></pre><h3>2. CSS</h3><p>Pertama, kita atur gaya untuk bodi utamanya. Alih-alih menggunakan trik border yang rumit, kita menggunakan <code>linear-gradient</code> untuk membagi latar belakang secara sempurna menjadi dua bagian.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">body {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 100vh;\n  background-color: #363588;\n}\n\n.balance {\n  width: 100px;\n  height: 50px;\n  background-color: white;\n  border: 4px solid black;\n  border-bottom-width: 52px;\n  border-radius: 100%;\n  position: relative;\n  box-sizing: content-box;\n  animation: rotate 3s infinite linear;\n}</code></pre><h3>3. Elemen Semu (Pseudo-Elements)</h3><p>Sekarang kita gunakan <code>::before</code> dan <code>::after</code> untuk membuat dua lingkaran di dalam. Kita menggunakan trik border di sini: <code>background-color</code> menciptakan titik kecil di dalam, sedangkan <code>border</code> menciptakan bagian pusaran lingkaran tersebut.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">/* The top white/black swirl with a black dot */\n.balance::before,\n.balance::after {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 0;\n  width: 12.5px; /* The size of the inner dot */\n  height: 12.5px;\n  background-color: white;\n  border: 18.8px solid black; /* The border creates the black head */\n  border-radius: 100%;\n  box-sizing: content-box;\n}\n.balance::after {\n  left: 50%;\n  background-color: black;\n  border-color: white; /* The border creates the white head */\n}</code></pre><h3>4. Animasi</h3><p>Terakhir, kita definisikan keyframes untuk membuat simbol berputar terus menerus.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">@keyframes rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}</code></pre><h3>Ringkasan</h3><p>Dengan menggabungkan gradien linear pada elemen induk dan elemen semu yang dipusatkan menggunakan border tebal, kita berhasil membuat animasi Yin-Yang yang skalabel dan tidak pecah (resolution-independent) tanpa menggunakan JavaScript sama sekali.</p>",
    "content_group_id": "0bc941c3-ad5c-49a4-6b7a-3daad153e6c5",
    "locale": "id",
    "cover_image_url": null,
    "tags": [
      "css",
      "animasi",
      "yin yang",
      "pseudo-elements",
      "gradien"
    ],
    "published": true,
    "published_at": "2025-12-09T10:00:00.000Z",
    "created_at": "2025-12-09T08:46:52.852Z",
    "updated_at": "2025-12-09T09:53:35.596Z",
    "price": null,
    "discount_percentage": null,
    "homepage": null,
    "product_description": null,
    "social_media_links": [],
    "preview_enabled": true
  },
  {
    "id": "blue-flame-tutorial-en",
    "slug": "blue-flame-particle-animation",
    "title": "Creating a Blue Flame Particle System with CSS & JS",
    "excerpt": "Learn how to build a procedural fire effect. This tutorial combines CSS blend modes for the glowing look and JavaScript to generate random particle movement.",
    "content": "<p>In this tutorial, we will create a magical blue flame effect. Unlike a static image, this fire is <strong>procedural</strong>. We use JavaScript to generate dozens of small particles and CSS to animate them upwards, creating a fluid, organic look.</p><h3>The Secret Sauce: Blend Modes</h3><p>The key to making the divs look like fire rather than just blue circles is <code>mix-blend-mode: screen</code>. When these particles overlap, their colors add up, creating intense white-hot centers and transparent edges.</p><h3>1. The HTML</h3><p>Our HTML is incredibly simple. We only need a container to hold our fire.</p><pre data-language=\"xml\" class=\"language-xml\"><code class=\"language-xml\">&lt;div class=\"circle\" id=\"circle\"&gt;&lt;/div&gt;</code></pre><h3>2. The CSS: Physics of Fire</h3><p>We use CSS Keyframes to define how a single particle behaves. It starts at the bottom, fades in, moves up (<code>translateY</code>), and eventually fades out while shrinking.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">@keyframes rise {\n  from {\n    opacity: 0;\n    transform: translateY(0) scale(1);\n  }\n  25% {\n    opacity: 1;\n  }\n  to {\n    opacity: 1;\n    transform: translateY(-10em) scale(0);\n  }\n}\n\n@keyframes orbit {\n  from {\n    transform: translate(-50%, -50%) rotate(0deg) translateX(12em)\n      rotate(0deg);\n  }\n  to {\n    transform: translate(-50%, -50%) rotate(360deg) translateX(12em)\n      rotate(-360deg);\n  }\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  background-color: #080830;\n  margin: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n  overflow: hidden;\n}\n\n.circle {\n  position: relative;\n  width: 40px;\n  height: 40px;\n  font-size: 24px;\n  transform: scale(0.5);\n}\n\n.fire {\n  filter: blur(0.02em);\n  position: absolute;\n  width: 10em;\n  height: 12em;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.fire.orb {\n  z-index: 10;\n}\n\n.fire.around {\n  width: 6em;\n  height: 7.2em;\n  font-size: 16px;\n  animation: orbit 8s linear infinite;\n}\n\n.flame {\n  animation: rise 2s ease-out infinite;\n  background-image: radial-gradient(\n    #0080ff 10%,\n    #00a0ff 30%,\n    rgba(0, 160, 255, 0) 70%\n  );\n  border-radius: 50%;\n  mix-blend-mode: screen;\n  opacity: 0;\n  position: absolute;\n  bottom: 0;\n  width: 5em;\n  height: 5em;\n}</code></pre><h3>3. The JavaScript: Generating Particles</h3><p>Writing 50 div elements manually is tedious. We use JavaScript to generate them. We also add <strong>randomness</strong> to the animation delays so the fire doesn't look like a repeating pattern.</p><pre data-language=\"javascript\" class=\"language-javascript\"><code class=\"language-javascript\">const circle = document.getElementById(\"circle\");\nconst flameCount = 50;\n\ncircle.appendChild(createFire(\"orb\"));\n\nfor (let i = 0; i &lt; 8; i++) {\n  circle.appendChild(createFire(\"around\", i));\n}\n\nfunction createFire(className, index = null) {\n  const fire = document.createElement(\"div\");\n  fire.className = `fire ${className}`;\n\n  for (let i = 0; i &lt; flameCount; i++) {\n    const flame = document.createElement(\"div\");\n    flame.className = \"flame\";\n\n    const delay = Math.random() * 1.5;\n    flame.style.animationDelay = `${delay}s`;\n\n    const duration = 1.2 + (Math.random() * 0.4 - 0.2);\n    flame.style.animationDuration = `${duration}s`;\n\n    const leftPosition = (i / (flameCount - 1)) * 100;\n    flame.style.left = `calc((100% - 5em) * ${leftPosition / 100})`;\n\n    fire.appendChild(flame);\n  }\n\n  if (index) {\n    fire.style.animationDelay = `${-index * 1}s`;\n    fire.style.setProperty(\"--angle\", `${index * 45}deg`);\n  }\n\n  return fire;\n}</code></pre><h3>Summary</h3><p>By generating many overlapping elements with slight random variations in speed and timing, we simulate the chaotic nature of real fire using standard DOM elements.</p>",
    "content_group_id": "1628fa27-1f7d-406f-b628-a08e4d151695",
    "locale": "en",
    "cover_image_url": null,
    "tags": [
      "css",
      "javascript",
      "particle system",
      "animation",
      "blend-mode"
    ],
    "published": true,
    "published_at": "2025-12-09T10:00:00.000Z",
    "created_at": "2025-12-09T08:46:52.852Z",
    "updated_at": "2025-12-09T10:37:46.226Z",
    "preview_enabled": true
  },
  {
    "id": "blue-flame-tutorial-id",
    "slug": "animasi-partikel-api-biru",
    "title": "Membuat Sistem Partikel Api Biru dengan CSS & JS",
    "excerpt": "Pelajari cara membuat efek api prosedural. Tutorial ini menggabungkan mode campuran CSS untuk tampilan bercahaya dan JavaScript untuk menghasilkan gerakan partikel acak.",
    "content": "<p>Dalam tutorial ini, kita akan membuat efek api biru yang ajaib. Tidak seperti gambar statis, api ini bersifat <strong>prosedural</strong>. Kita menggunakan JavaScript untuk menghasilkan puluhan partikel kecil dan CSS untuk menggerakkannya ke atas, menciptakan tampilan yang cair dan organik.</p><h3>Rahasia Utama: Blend Modes</h3><p>Kunci agar elemen div terlihat seperti api, bukan hanya lingkaran biru, adalah <code>mix-blend-mode: screen</code>. Ketika partikel-partikel ini saling tumpang tindih, warnanya akan menyatu (additive), menciptakan pusat yang putih panas dan tepi yang transparan.</p><h3>1. HTML</h3><p>HTML kita sangat sederhana. Kita hanya membutuhkan wadah (container) untuk menampung api kita.</p><pre data-language=\"xml\" class=\"language-xml\"><code class=\"language-xml\">&lt;div class=\"circle\" id=\"circle\"&gt;&lt;/div&gt;</code></pre><h3>2. CSS: Fisika Api</h3><p>Kita menggunakan CSS Keyframes untuk menentukan perilaku satu partikel. Partikel dimulai dari bawah, memudar masuk (fade in), bergerak ke atas (<code>translateY</code>), dan akhirnya memudar keluar sambil mengecil.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">@keyframes rise {\n  from {\n    opacity: 0;\n    transform: translateY(0) scale(1);\n  }\n  25% {\n    opacity: 1;\n  }\n  to {\n    opacity: 1;\n    transform: translateY(-10em) scale(0);\n  }\n}\n\n@keyframes orbit {\n  from {\n    transform: translate(-50%, -50%) rotate(0deg) translateX(12em)\n      rotate(0deg);\n  }\n  to {\n    transform: translate(-50%, -50%) rotate(360deg) translateX(12em)\n      rotate(-360deg);\n  }\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  background-color: #080830;\n  margin: 0;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n  overflow: hidden;\n}\n\n.circle {\n  position: relative;\n  width: 40px;\n  height: 40px;\n  font-size: 24px;\n  transform: scale(0.5);\n}\n\n.fire {\n  filter: blur(0.02em);\n  position: absolute;\n  width: 10em;\n  height: 12em;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.fire.orb {\n  z-index: 10;\n}\n\n.fire.around {\n  width: 6em;\n  height: 7.2em;\n  font-size: 16px;\n  animation: orbit 8s linear infinite;\n}\n\n.flame {\n  animation: rise 2s ease-out infinite;\n  background-image: radial-gradient(\n    #0080ff 10%,\n    #00a0ff 30%,\n    rgba(0, 160, 255, 0) 70%\n  );\n  border-radius: 50%;\n  mix-blend-mode: screen;\n  opacity: 0;\n  position: absolute;\n  bottom: 0;\n  width: 5em;\n  height: 5em;\n}</code></pre><h3>3. JavaScript: Menghasilkan Partikel</h3><p>Menulis 50 elemen div secara manual sangat melelahkan. Kita menggunakan JavaScript untuk membuatnya secara otomatis. Kita juga menambahkan <strong>pengacakan (randomness)</strong> pada penundaan animasi agar api tidak terlihat seperti pola yang berulang kaku.</p><pre data-language=\"javascript\" class=\"language-javascript\"><code class=\"language-javascript\">const circle = document.getElementById(\"circle\");\nconst flameCount = 50;\n\ncircle.appendChild(createFire(\"orb\"));\n\nfor (let i = 0; i &lt; 8; i++) {\n  circle.appendChild(createFire(\"around\", i));\n}\n\nfunction createFire(className, index = null) {\n  const fire = document.createElement(\"div\");\n  fire.className = `fire ${className}`;\n\n  for (let i = 0; i &lt; flameCount; i++) {\n    const flame = document.createElement(\"div\");\n    flame.className = \"flame\";\n\n    const delay = Math.random() * 1.5;\n    flame.style.animationDelay = `${delay}s`;\n\n    const duration = 1.2 + (Math.random() * 0.4 - 0.2);\n    flame.style.animationDuration = `${duration}s`;\n\n    const leftPosition = (i / (flameCount - 1)) * 100;\n    flame.style.left = `calc((100% - 5em) * ${leftPosition / 100})`;\n\n    fire.appendChild(flame);\n  }\n\n  if (index) {\n    fire.style.animationDelay = `${-index * 1}s`;\n    fire.style.setProperty(\"--angle\", `${index * 45}deg`);\n  }\n\n  return fire;\n}</code></pre><h3>Ringkasan</h3><p>Dengan menghasilkan banyak elemen yang saling tumpang tindih dengan sedikit variasi acak dalam kecepatan dan waktu, kita mensimulasikan sifat kacau api asli menggunakan elemen DOM standar.</p>",
    "content_group_id": "1628fa27-1f7d-406f-b628-a08e4d151695",
    "locale": "id",
    "cover_image_url": null,
    "tags": [
      "css",
      "javascript",
      "sistem partikel",
      "animasi",
      "blend-mode"
    ],
    "published": true,
    "published_at": "2025-12-09T10:00:00.000Z",
    "created_at": "2025-12-09T08:46:52.852Z",
    "updated_at": "2025-12-09T10:37:19.152Z",
    "preview_enabled": true
  },
  {
    "id": "one-piece-flag-css-only-en",
    "slug": "one-piece-straw-hat-flag-css",
    "title": "Drawing the One Piece Straw Hat Pirate Flag",
    "excerpt": "A deep dive into complex CSS gradients and multiple backgrounds to recreate the iconic Jolly Roger of the Straw Hat Pirates. This artwork uses no images or SVG.",
    "content": "<h2>Introduction to CSS Art</h2><p>This tutorial demonstrates how to leverage advanced CSS techniquesâ€”specifically, multiple <code>radial-gradient</code> and <code>linear-gradient</code> layersâ€”to draw detailed illustrations, such as the famous Straw Hat Pirates flag from *One Piece*, using only one HTML element.</p><h3>The Technique: Layering Backgrounds</h3><p>The entire skull and crossbones is constructed by layering various gradients within the <code>background</code> property of the main element (<code>.one-piece</code>) and its pseudo-elements (<code>::before</code> and <code>::after</code>). Each gradient line and circle is a separate layer.</p><h3>1. The HTML Structure</h3><p>We use a single container element, setting a CSS Variable (<code>--s</code>) for easy scaling of the entire flag.</p><pre data-language=\"xml\" class=\"language-xml\"><code class=\"language-xml\">&lt;div class=\"one-piece\"&gt;&lt;/div&gt;</code></pre><h3>2. The CSS: Building the Skull</h3><p>The main class <code>.one-piece</code> handles the skull, the crossbones (implicitly), and the distinctive straw hat. The layering is critical, starting from the skull's core and moving outward to the hat's details.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  background: #000;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100vh;\n}\n\n.one-piece {\n  --s: 200px;\n  height: var(--s);\n  aspect-ratio: 1;\n  position: relative;\n\n  background: radial-gradient(#000 70%, #0000 73%) 50% 57% / 7% 7%,\n    radial-gradient(#000 70%, #0000 73%) 39% 48% / 14% 14%,\n    radial-gradient(#000 70%, #0000 73%) 61% 48% / 14% 14%,\n    linear-gradient(#000 0 0) 50% 39% / 69% 2px,\n    linear-gradient(#000 0 0) 50% 35.8% / 59% 2px,\n    linear-gradient(#000 0 0) 50% 31% / 42% 2px,\n    radial-gradient(50% 100% at 50% 134%, #f0b114 98%, #0000) 50% 15% /\n      44% 19%,\n    radial-gradient(50% 84% at 50% 100%, #cf091a 98%, #0000) 50% 24% / 44%\n      16%,\n    radial-gradient(50% 23% at 50% 100%, #f0b114 98%, #0000) 50% 24% / 68%\n      20%,\n    radial-gradient(#fff 67.5%, #000 68.5% 70%, #0000 71%) 50% 34% / 47%\n      47%;\n  background-repeat: no-repeat;\n}</code></pre><h3>3. The Pseudo-Elements: Bones and Background</h3><p>The <code>::before</code> element is used to draw the crossbones, using multiple black linear gradients for the bone shape and white as the background color. The <code>::after</code> element is used primarily for the **black circular flag background** and adds a subtle blurred border effect.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">/* ::before: Creates the crossbones */\n.one-piece::before {\n  content: \"\";\n  position: absolute;\n  inset: 55% 37% 20%;\n  border: 2px solid #000;\n  border-radius: 14% 14% 30px 30px / 50% 50% 30px 30px;\n\n  background: linear-gradient(#000 0 0) 78% 50% / 4% 43%,\n    linear-gradient(#000 0 0) 22% 50% / 4% 43%,\n    linear-gradient(#000 0 0) 50% 50% / 4% 47%,\n    radial-gradient(75% 57% at 50% 0, #0000 91%, #000 93% 98%, #0000),\n    radial-gradient(85% 76% at 50% 0, #0000 93%, #000 95% 98%, #0000) #fff;\n  background-repeat: no-repeat;\n  z-index: -1;\n}\n\n/* ::after: Creates the main circular flag and subtle outline */\n.one-piece::after {\n  content: \"\";\n  position: absolute;\n  inset: 0;\n  padding: 10%;\n  z-index: -2;\n  filter: blur(4px) contrast(10);\n\n  background: radial-gradient(#fff 66%, #0000 71%) 10% 97% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 3% 90% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 97% 91% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 89% 98% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 89% 2% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 98% 9% / 12% 10%,\n    radial-gradient(#fff 66%, #0000 71%) 2% 10% / 11% 10%,\n    radial-gradient(#fff 66%, #0000 71%) 9% 2% / 10% 11%,\n    linear-gradient(45deg, #0000 47%, #fff 0 53%, #0000 0) content-box,\n    linear-gradient(-45deg, #0000 47%, #fff 0 53%, #0000 0) content-box,\n    #000;\n  background-repeat: no-repeat;\n}</code></pre><h3>Summary</h3><p>By carefully positioning and sizing dozens of simple gradients on three stacked elements, we successfully render a recognizable, complex graphic. This method showcases the power of pure CSS for graphic creation.</p>",
    "content_group_id": "24de08e2-a912-4c77-840c-87923315f8ab",
    "locale": "en",
    "cover_image_url": null,
    "tags": [
      "css-art",
      "one-piece",
      "gradient",
      "jolly-roger",
      "anime"
    ],
    "published": true,
    "published_at": "2025-12-09T10:00:00.000Z",
    "created_at": "2025-12-09T08:46:52.852Z",
    "updated_at": "2025-12-09T10:40:26.271Z",
    "price": null,
    "discount_percentage": null,
    "homepage": null,
    "product_description": null,
    "social_media_links": [],
    "preview_enabled": true
  },
  {
    "id": "one-piece-flag-css-only-id",
    "slug": "bendera-topi-jerami-one-piece-css",
    "title": "Menggambar Bendera Bajak Laut Topi Jerami One Piece",
    "excerpt": "Analisis mendalam tentang gradien CSS yang kompleks dan latar belakang ganda untuk menciptakan Jolly Roger ikonik Bajak Laut Topi Jerami. Karya seni ini tidak menggunakan gambar atau SVG.",
    "content": "<p>Tutorial ini menunjukkan cara memanfaatkan teknik CSS tingkat lanjutâ€”khususnya, lapisan <code>radial-gradient</code> dan <code>linear-gradient</code> bergandaâ€”untuk menggambar ilustrasi detail, seperti bendera Bajak Laut Topi Jerami yang terkenal dari *One Piece*, hanya menggunakan satu elemen HTML.</p><h3>Teknik: Melapisi Latar Belakang</h3><p>Seluruh tengkorak dan tulang bersilang (crossbones) dibangun dengan melapisi berbagai gradien di dalam properti <code>background</code> elemen utama (<code>.one-piece</code>) dan elemen semunya (<code>::before</code> dan <code>::after</code>). Setiap garis dan lingkaran gradien adalah lapisan terpisah.</p><h3>1. Struktur HTML</h3><p>Kita menggunakan satu elemen wadah, menetapkan Variabel CSS (<code>--s</code>) untuk memudahkan penskalaan seluruh bendera.</p><pre data-language=\"xml\" class=\"language-xml\"><code class=\"language-xml\">&lt;div class=\"one-piece\"&gt;&lt;/div&gt;</code></pre><h3>2. CSS: Membangun Tengkorak</h3><p>Kelas utama <code>.one-piece</code> menangani tengkorak, tulang bersilang (secara implisit), dan topi jerami yang khas. Pelapisan sangat penting, dimulai dari inti tengkorak dan bergerak keluar hingga detail topi.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  background: #000;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100vh;\n}\n\n.one-piece {\n  --s: 200px;\n  height: var(--s);\n  aspect-ratio: 1;\n  position: relative;\n\n  background: radial-gradient(#000 70%, #0000 73%) 50% 57% / 7% 7%,\n    radial-gradient(#000 70%, #0000 73%) 39% 48% / 14% 14%,\n    radial-gradient(#000 70%, #0000 73%) 61% 48% / 14% 14%,\n    linear-gradient(#000 0 0) 50% 39% / 69% 2px,\n    linear-gradient(#000 0 0) 50% 35.8% / 59% 2px,\n    linear-gradient(#000 0 0) 50% 31% / 42% 2px,\n    radial-gradient(50% 100% at 50% 134%, #f0b114 98%, #0000) 50% 15% /\n      44% 19%,\n    radial-gradient(50% 84% at 50% 100%, #cf091a 98%, #0000) 50% 24% / 44%\n      16%,\n    radial-gradient(50% 23% at 50% 100%, #f0b114 98%, #0000) 50% 24% / 68%\n      20%,\n    radial-gradient(#fff 67.5%, #000 68.5% 70%, #0000 71%) 50% 34% / 47%\n      47%;\n  background-repeat: no-repeat;\n}</code></pre><h3>3. Elemen Semu: Tulang dan Latar Belakang</h3><p>Elemen <code>::before</code> digunakan untuk menggambar tulang bersilang, menggunakan beberapa gradien linear hitam untuk bentuk tulang dan putih sebagai warna latar belakang. Elemen <code>::after</code> terutama digunakan untuk **latar belakang bendera melingkar hitam** dan menambahkan efek border blur yang halus.</p><pre data-language=\"css\" class=\"language-css\"><code class=\"language-css\">/* ::before: Menciptakan tulang bersilang */\n.one-piece::before {\n  content: \"\";\n  position: absolute;\n  inset: 55% 37% 20%;\n  border: 2px solid #000;\n  border-radius: 14% 14% 30px 30px / 50% 50% 30px 30px;\n\n  background: linear-gradient(#000 0 0) 78% 50% / 4% 43%,\n    linear-gradient(#000 0 0) 22% 50% / 4% 43%,\n    linear-gradient(#000 0 0) 50% 50% / 4% 47%,\n    radial-gradient(75% 57% at 50% 0, #0000 91%, #000 93% 98%, #0000),\n    radial-gradient(85% 76% at 50% 0, #0000 93%, #000 95% 98%, #0000) #fff;\n  background-repeat: no-repeat;\n  z-index: -1;\n}\n\n/* ::after: Menciptakan bendera melingkar utama dan garis luar yang halus */\n.one-piece::after {\n  content: \"\";\n  position: absolute;\n  inset: 0;\n  padding: 10%;\n  z-index: -2;\n  filter: blur(4px) contrast(10);\n\n  background: radial-gradient(#fff 66%, #0000 71%) 10% 97% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 3% 90% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 97% 91% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 89% 98% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 89% 2% / 10% 11%,\n    radial-gradient(#fff 66%, #0000 71%) 98% 9% / 12% 10%,\n    radial-gradient(#fff 66%, #0000 71%) 2% 10% / 11% 10%,\n    radial-gradient(#fff 66%, #0000 71%) 9% 2% / 10% 11%,\n    linear-gradient(45deg, #0000 47%, #fff 0 53%, #0000 0) content-box,\n    linear-gradient(-45deg, #0000 47%, #fff 0 53%, #0000 0) content-box,\n    #000;\n  background-repeat: no-repeat;\n}</code></pre><h3>Ringkasan</h3><p>Dengan memposisikan dan mengukur puluhan gradien sederhana secara cermat pada tiga elemen yang ditumpuk, kita berhasil merender grafik yang kompleks dan dapat dikenali. Metode ini menunjukkan kekuatan CSS murni untuk kreasi grafis.</p>",
    "content_group_id": "24de08e2-a912-4c77-840c-87923315f8ab",
    "locale": "id",
    "cover_image_url": null,
    "tags": [
      "css-art",
      "one-piece",
      "gradient",
      "jolly-roger",
      "anime"
    ],
    "published": true,
    "published_at": "2025-12-09T10:00:00.000Z",
    "created_at": "2025-12-09T08:46:52.852Z",
    "updated_at": "2025-12-09T10:46:29.246Z",
    "price": null,
    "discount_percentage": null,
    "homepage": null,
    "product_description": null,
    "social_media_links": [],
    "preview_enabled": true
  }
]